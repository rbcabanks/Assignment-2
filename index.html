<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
	<title>Assignment 5a</title>
</head>
<style>
	html,
	body {
		height: 100%;
		margin: 0;
	}

	#c {
		width: 100%;
		height: 100%;
		display: block;
	}
</style>

<body>
	<canvas id="c"></canvas>
</body>
<script type="importmap">{
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
        }
    </script>
<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
	import { Water } from 'three/addons/objects/Water.js';
	import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
	import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';


	function main() {

		const canvas = document.querySelector('#c');
		//const renderer = new THREE.WebGLRenderer( { antialias: true, canvas } );
		// want to use skybox 
		const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });


		const fov = 100;
		const aspect = window.innerWidth / window.innerHeight; // the canvas default
		const near = 1;
		const far = 20000;
		const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		camera.position.set(-50, 50, 90);
		// using example from "cameras" as a basic guide
		function updateCamera() {
			camera.updateProjectionMatrix();
		}

		const controls = new OrbitControls(camera, canvas);
		controls.target.set(-5, 10, 0);
		// got help with formatting the camera above the water from this example"https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shaders_ocean.html" 
		controls.maxPolarAngle = Math.PI * 0.495;
		//controls.minDistance = 40.0;
		controls.maxDistance = 200;
		controls.update();

		const scene = new THREE.Scene();
		const waterGeometry = new THREE.PlaneGeometry(20000, 20000);
		let water;

		//had to tweak it to be how I wanted, but got a lot of help from this source code https://threejs.org/examples/webgl_shaders_ocean.html
		water = new Water(
			waterGeometry,
			{
				textureWidth: 10000,
				textureHeight: 10000,
				waterNormals: new THREE.TextureLoader().load('waternormals.jpg', function (texture) {

					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

				}),
				
				//sunDirection: new THREE.Vector3(),
				sunColor: 0x8B6700,
				waterColor: 0x000000,
				distortionScale: 3.7,
				fog: scene.fog !== undefined
			}
		);

		water.rotation.x = - Math.PI / 2;
		scene.add(water);

		//loading in a 3d scenery
		{
			const loader = new THREE.CubeTextureLoader();
			const texture = loader.load([
				'cubemap/pano_r.jpg', //pos-x
				'cubemap/pano_l.jpg', //neg-x

				'cubemap/pano_u.jpg', //pos-y
				'cubemap/pano_d.jpg', //neg-y

				'cubemap/pano_f.jpg', //pos-z
				'cubemap/pano_b.jpg', //neg-z
				//bfrl 
				//sourced from https://www.utah3d.net/utah-travel/utah-waterways/starry-lake.html
			]);
			scene.background = texture;
		}

		{// drone obj and mtl. Got from this source https://www.cgtrader.com/items/2480872/download-page
			const mtlLoader = new MTLLoader();
			mtlLoader.load('drone.mtl', (mtl) => {
				mtl.preload();
				const objLoader = new OBJLoader();
				objLoader.setMaterials(mtl);
				objLoader.load('drone.obj', (root) => {
					root.position.y = 5;
					root.position.x = -5;
					root.position.z = -10;
					root.scale.set(25, 25, 25)
					scene.add(root);
				});

			});
		}
		
		// the 20+ cubes or other shapes
		let cube,cube1,cube2,cube3,cube4,cube5,cube6,cube7,cube8,cube9,cube10,cube11;
			//creating propellers 
			{
				const cubeSize = .5;
				const cubeGeo = new THREE.BoxGeometry( cubeSize*15, cubeSize, cubeSize );
				const cubeMat = new THREE.MeshPhongMaterial( { color: '#000000' } );
				cube = new THREE.Mesh( cubeGeo, cubeMat );
				cube1 = new THREE.Mesh( cubeGeo, cubeMat );
				cube2 = new THREE.Mesh( cubeGeo, cubeMat );
				cube3 = new THREE.Mesh( cubeGeo, cubeMat );
				cube4 = new THREE.Mesh( cubeGeo, cubeMat );				
				cube5 = new THREE.Mesh( cubeGeo, cubeMat );
				cube6 = new THREE.Mesh( cubeGeo, cubeMat );
				cube7 = new THREE.Mesh( cubeGeo, cubeMat );
				cube8 = new THREE.Mesh( cubeGeo, cubeMat );				
				cube9 = new THREE.Mesh( cubeGeo, cubeMat );
				cube10 = new THREE.Mesh( cubeGeo, cubeMat );
				cube11= new THREE.Mesh( cubeGeo, cubeMat );

				
				cube.position.set(4.6, 41, -3.5 );
				cube1.position.set(-14.4, 41, -3.5 );
				cube2.position.set(-14.4, 41, -17.4 );
				cube3.position.set(4.6, 41, -17.4 );

				cube4.rotation.y=45;
				cube5.rotation.y=45;
				cube6.rotation.y=45;
				cube7.rotation.y=45;
				cube4.position.set(4.6, 41, -3.5 );
				cube5.position.set(-14.4, 41, -3.5 );
				cube6.position.set(-14.4, 41, -17.4 );
				cube7.position.set(4.6, 41, -17.4 );

				cube8.rotation.y=90;
				cube9.rotation.y=90;
				cube10.rotation.y=90;
				cube11.rotation.y=90;
				cube8.position.set(4.6, 41, -3.5 );
				cube9.position.set(-14.4, 41, -3.5 );
				cube10.position.set(-14.4, 41, -17.4 );
				cube11.position.set(4.6, 41, -17.4 );

				//cube.rotation.x = 13;
				scene.add( cube );
				scene.add( cube1 );
				scene.add( cube2 );
				scene.add( cube3 );
				scene.add( cube4 );
				scene.add( cube5 );
				scene.add( cube6 );
				scene.add( cube7 );
				scene.add( cube8 );
				scene.add( cube9 );
				scene.add( cube10 );
				scene.add( cube11 );
			}
			


		//lighting
		{

			const color = 0xffeca1;
			const intensity = 3;
			//light 1
			const light = new THREE.DirectionalLight(color, intensity);
			const light2 = new THREE.DirectionalLight(0x008080, 3);

			//light 2
			const alight = new THREE.AmbientLight(0x101647, .01);
			//light 3
			const hlight = new THREE.HemisphereLight(0xB1E1FF, 0x101647, .01);
			
			scene.add(alight);
			scene.add(light2);
			scene.add(hlight);
			light.position.set(180, 10, 0);
			light2.position.set(-170, 5, -600);
			light2.target.position.set(-5, 4, 10);
			light.target.position.set(-5, 4, 10);
			scene.add(light);
			scene.add(light.target);

		}

		function resizeRendererToDisplaySize(renderer) {

			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {

				renderer.setSize(width, height, false);

			}

			return needResize;

		}
		
		function render() {

			
			if (resizeRendererToDisplaySize(renderer)) {

				const canvas = renderer.domElement;
				camera.aspect = canvas.clientWidth / canvas.clientHeight;
				camera.updateProjectionMatrix();

			}
			
			//makes water move.. got help from this example https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shaders_ocean.html
			water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
			
			//propeller animations
			cube.rotation.y += 0.4;
			cube1.rotation.y += 0.4;
			cube2.rotation.y += 0.4;
			cube3.rotation.y += 0.4;
			cube4.rotation.y += 0.4;
			cube5.rotation.y += 0.4;
			cube6.rotation.y += 0.4;
			cube7.rotation.y += 0.4;
			cube8.rotation.y += 0.4;
			cube9.rotation.y += 0.4;
			cube10.rotation.y += 0.4;
			cube11.rotation.y += 0.4;

			renderer.render(scene, camera);
			requestAnimationFrame(render);

		}

		requestAnimationFrame(render);
	}

	main();
</script>
