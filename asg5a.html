<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Three.js - Fundamentals with light</title>
  </head>
  <style>
    html, body {
    height: 100%;
    margin: 0;
    }
    #c {
    width: 100%;
    height: 100%;
    display: block;
    }
    </style>

  <body>
    <canvas id="c" ></canvas>
  </body>
    <script  type="importmap">{
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
        }
    </script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import { Sky } from 'three/addons/objects/Sky.js';

    function main() {

        const canvas = document.querySelector( '#c' );
        const renderer = new THREE.WebGLRenderer( { antialias: true, canvas } );

        const fov = 45;
        const aspect = 2; // the canvas default
        const near = 0.1;
        const far = 100;
        const camera = new THREE.PerspectiveCamera( fov, aspect, near, far );
        camera.position.set( 0, 10, 20 );

        class MinMaxGUIHelper {
            constructor( obj, minProp, maxProp, minDif ) {
                this.obj = obj;
                this.minProp = minProp;
                this.maxProp = maxProp;
                this.minDif = minDif;
            }
            get min() {
                return this.obj[ this.minProp ];
            }
            set min( v ) {
                this.obj[ this.minProp ] = v;
                this.obj[ this.maxProp ] = Math.max( this.obj[ this.maxProp ], v + this.minDif );
            }
            get max() {
                return this.obj[ this.maxProp ];
            }
            set max( v ) {
                this.obj[ this.maxProp ] = v;
                this.min = this.min; // this will call the min setter
            }

        }
        
        function updateCamera() {
            camera.updateProjectionMatrix();

        }

        
        const controls = new OrbitControls( camera, canvas );
        controls.target.set( 0, 5, 0 );
        controls.update();

        // background color
        const scene = new THREE.Scene();
        //scene.background = new THREE.Color(0x080824);
        // Add Sky
        let sky, sun;
        {
        sky = new Sky();
        sky.scale.setScalar( 450000 );
        scene.add( sky );

        sun = new THREE.Vector3();

        /// GUI
        const effectController = {
            turbidity: .1,
            rayleigh: .017,
            mieCoefficient: .002,
            mieDirectionalG: 0.766,
            elevation: 10.3,
            azimuth: 180,
            exposure: renderer.toneMappingExposure
            }
        const uniforms = sky.material.uniforms;
            uniforms[ 'turbidity' ].value = effectController.turbidity;
            uniforms[ 'rayleigh' ].value = effectController.rayleigh;
            uniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;
            uniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;
        const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
        const theta = THREE.MathUtils.degToRad( effectController.azimuth );

        sun.setFromSphericalCoords( 1, phi, theta );

        uniforms[ 'sunPosition' ].value.copy( sun );

        renderer.toneMappingExposure = effectController.exposure;
        renderer.render( scene, camera );
        }
        //sphere
        {
            const sphereRadius = 3;
            const sphereWidthDivisions = 32;
            const sphereHeightDivisions = 16;
            const sphereGeo = new THREE.SphereGeometry( sphereRadius, sphereWidthDivisions, sphereHeightDivisions );
            const sphereMat = new THREE.MeshPhongMaterial( { color: 'white' } );
            const mesh = new THREE.Mesh( sphereGeo, sphereMat );
            mesh.position.set( - sphereRadius - 1, sphereRadius + 2, 0 );
            scene.add( mesh );

        }

        /*
        //plane
            const planeSize = 100;

            const loader = new THREE.TextureLoader();
            const texture = loader.load( 'grass.png' );

            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter;
            //texture.colorSpace = THREE.SRGBColorSpace;
            const repeats = 1;
            texture.repeat.set( repeats, repeats );


            const planeGeo = new THREE.PlaneGeometry( planeSize, planeSize );
            const planeMat = new THREE.MeshPhongMaterial( {
                map: texture,
                side: THREE.DoubleSide,
            } );
            const mesh = new THREE.Mesh( planeGeo, planeMat );
            mesh.rotation.x = Math.PI * - .5;
            scene.add( mesh );
*/

        //light on objects
        {
            const color = 0xFFFFFF;
            const intensity = .5;
            const light = new THREE.DirectionalLight( color, intensity );
            //light.position.set( 1, 5, 0 );
            //light.target.position.set( - 5, 0, 0 );
            const alight = new THREE.AmbientLight(0x333333); // soft white light
            scene.add(alight );
            light.position.x=1;
            scene.add( light );
            //scene.add( light.target );

        }

        function resizeRendererToDisplaySize( renderer ) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if ( needResize ) {

                renderer.setSize( width, height, false );

            }

            return needResize;

        }

        function render() {

            if ( resizeRendererToDisplaySize( renderer ) ) {

                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();

            }

            renderer.render( scene, camera );

            requestAnimationFrame( render );

        }

        requestAnimationFrame( render );

    }

    main();

  </script>
