<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Three.js - Fundamentals with light</title>
  </head>
  <style>
    html, body {
    height: 100%;
    margin: 0;
    }
    #c {
    width: 100%;
    height: 100%;
    display: block;
    }
    </style>

  <body>
    <canvas id="c" ></canvas>
  </body>
    <script  type="importmap">{
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
        }
    </script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import { Water } from 'three/addons/objects/Water.js';

    function main() {

        const canvas = document.querySelector( '#c' );
        const renderer = new THREE.WebGLRenderer( { antialias: true, canvas } );
        //renderer.toneMapping = THREE.ACESFilmicToneMapping; // used for exposure of sky
        //renderer.toneMappingExposure = 0.1;  // used for exposure

        const fov = 45;
        const aspect = 2; // the canvas default
        const near = 0.1;
        const far = 100;
        const camera = new THREE.PerspectiveCamera( fov, aspect, near, far );
        camera.position.set(0, 5, 50 );

        class MinMaxGUIHelper {
            constructor( obj, minProp, maxProp, minDif ) {
                this.obj = obj;
                this.minProp = minProp;
                this.maxProp = maxProp;
                this.minDif = minDif;
            }
            get min() {
                return this.obj[ this.minProp ];
            }
            set min( v ) {
                this.obj[ this.minProp ] = v;
                this.obj[ this.maxProp ] = Math.max( this.obj[ this.maxProp ], v + this.minDif );
            }
            get max() {
                return this.obj[ this.maxProp ];
            }
            set max( v ) {
                this.obj[ this.maxProp ] = v;
                this.min = this.min; // this will call the min setter
            }

        }
        
        function updateCamera() {
            camera.updateProjectionMatrix();

        }
      
        const controls = new OrbitControls( camera, canvas );
        controls.target.set( 0, 5, 0 );
        controls.update();
        const scene = new THREE.Scene();

        
		const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );
        let water;
        water = new Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load( 'waternormals.jpg', function ( texture ) {

                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

                } ),
                
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            }
        );

        water.rotation.x = - Math.PI / 2;

        scene.add( water );
        //water.material.uniforms[ 'flowDirection' ].value.normalize();
        //sphere
        
        {
            const sphereRadius = 3;
            const sphereWidthDivisions = 32;
            const sphereHeightDivisions = 16;
            const sphereGeo = new THREE.SphereGeometry( sphereRadius, sphereWidthDivisions, sphereHeightDivisions );
            const sphereMat = new THREE.MeshPhongMaterial( { color: 'white' } );
            const mesh = new THREE.Mesh( sphereGeo, sphereMat );
            mesh.position.set( - sphereRadius - 1, sphereRadius + 2, 0 );
            scene.add( mesh );

        }

        {
        const loader = new THREE.CubeTextureLoader();
        const texture = loader.load([
            'resources/images/cubemaps/computer-history-museum/pos-x.jpg',
            'resources/images/cubemaps/computer-history-museum/neg-x.jpg',
            'resources/images/cubemaps/computer-history-museum/pos-y.jpg',
            'resources/images/cubemaps/computer-history-museum/neg-y.jpg',
            'resources/images/cubemaps/computer-history-museum/pos-z.jpg',
            'resources/images/cubemaps/computer-history-museum/neg-z.jpg',
        ]);
        scene.background = texture;
        }

        //light on objects
        // light
        {
            
        }


        function resizeRendererToDisplaySize( renderer ) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if ( needResize ) {

                renderer.setSize( width, height, false );

            }

            return needResize;

        }

        function render() {

            if ( resizeRendererToDisplaySize( renderer ) ) {

                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();

            }

            renderer.render( scene, camera );
            requestAnimationFrame( render );

        }

        requestAnimationFrame( render );

    }

    main();

  </script>
